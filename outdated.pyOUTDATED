"""
def multiple_white_rec(line, comb_white, line_w_init, static_pins_init=[]):
    n=0
    #Gets the list of pins not used in current white combination
    free_indices = np.setdiff1d(np.arange(line.size), comb_white)
    line_free = line[free_indices]
    print("  "*len(comb_white), "Free indices",free_indices,"Line free", line_free)
    #Iterates over evey current white combination color
    for pin in set(line[list(comb_white)]):
        static_pins = static_pins_init.copy()
        #print("  "*len(comb_white), "Pin", pin, "Static Pins", static_pins)
        if pin not in line_free:
            #Calculates new line when swapped_pin is swapped with pin
            static_pins+=[pin]
            n+=white_rec({i:line[i] for i in comb_white}, np.stack((line, np.arange(line.size))), {i:np.arange(1,9) for i in range(line.size)}, line, static_pins)
            if len(static_pins)<line.size-1:
                n+=multiple_white_rec(line, comb_white, line_w_init, static_pins)
    return n

def white_rec(line_w, line_free, free_colors, line_w_init, static_pins=[]):
    n = 0
    if len(line_w)>0:
        #print(" "*(2-len(line_w)),"Line w", line_w, "Line free", line_free)
        pin = list(line_w.items())[0]
        for new_pin, new_position in zip(line_free[0], line_free[1]):
            #print(" "*(2-len(line_w)),"Pin", pin,"New pin", new_pin, new_position)
            if new_pin!=pin[1]:
                #print(" "*(2-len(line_w)),"Pin ok")
                _=free_colors.copy()
                if pin[0] in _:
                    _[pin[0]][pin[1]-1]=0
                _.pop(new_position)
                #print(" "*(2-len(line_w)),_)
                n+=white_rec({i[0]:i[1] for i in line_w.items() if i[0]!=pin[0]}, line_free[:,line_free[1]!=new_position], _, line_w_init, static_pins)
        return n
    else:
        l1 = len(free_colors)
        l2 = len(static_pins)
        print(static_pins, free_colors)
        if l1>=l2:
            for comb_static in itertools.combinations(free_colors.keys(),l1-l2):
                color_list = [free_colors[free_color_pin] for free_color_pin in comb_static]
                print(color_list, line_w_init)
                n+=np.prod([np.sum(np.isin(i,np.setdiff1d(np.arange(1,9),line_w_init))) for i in color_list])
            return n
        else:
            return 0

def count_white(line, w):
    l = np.arange(line.size)
    line_stacked = np.stack((line, np.arange(line.size)))
    n = 0
    #Iterates over every possible white combination
    for comb_white in set(itertools.combinations(line_stacked[0], w)):
        print("-----",line[np.array(comb_white)],"-----")
        #Counts number of combinations using current white combination's colors only once
        n+=white_rec({i:line[i] for i in comb_white}, {i:np.arange(1,9) for i in range(line.size)}, line)
        #Counts number of combiation using current white combination's colors mutltiple times
        n+=multiple_white_rec(line, comb_white, line)
    return n

def count(line, w, r):
    n = 0
    #Iterates over every possible red combination
    for comb_red in itertools.combinations(range(4), 4-r):
        #Gets remaining pins
        new_l = line[list(comb_red)]
        #Counts possibilities of white placements
        n+=count_white(new_l, w)
    return n
"""